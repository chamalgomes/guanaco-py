name: Build and Publish Wheels

# NOTE: This was a headcache to set up GitHub Actions for building and publishing wheels.
# - This workflow builds wheels for CPU and CUDA (12.1 to 12.4) on multiple Python versions.
# - It creates GitHub Releases for each build and uploads the wheels there.
# - It generates a PEP 503-compliant simple index for installing via pip from GitHub Pages.
# - The workflow is triggered on new tags (v*), manual dispatch, and weekly schedule.
# This could broke on any changes to the repo structure or GitHub Actions environment. (i need make this more robust eventually)

on:
  workflow_dispatch:
  push:
    tags: ["v*"]
  schedule:
    - cron: '0 0 * * 0'

# permissions needed for releases and GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write

# limit concurrent, i mean, don't run multiple builds at once
concurrency:
  group: "pages"
  cancel-in-progress: false


jobs:
  get_version:
    name: Get Version
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.set-version.outputs.version }}
    steps:
      - uses: actions/checkout@v6
      - name: Extract version
        id: set-version
        shell: pwsh

        # extract __version__ from llama_cpp/__init__.py
        run: |
          $version = Select-String -Path "llama_cpp/__init__.py" -Pattern '__version__ = "([^"]+)"' | % { $_.Matches.Groups[1].Value }
          Write-Output "version=$version" >> $env:GITHUB_OUTPUT

  define_matrix_cuda:
    name: Define CUDA Build Matrix
    runs-on: ubuntu-22.04
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    needs: get_version
    defaults:
      run:
        shell: pwsh
    steps:
      - name: Define Job Output
        id: set-matrix
        run: |
          $pyvers = @("3.9", "3.10", "3.11", "3.12")
          $cudavers = @("12.1.1", "12.2.2", "12.3.2", "12.4.1")
          $shorts = @("cu121", "cu122", "cu123", "cu124")

          $includes = @()

          for ($i = 0; $i -lt $cudavers.Length; $i++) {
            $cuda = $cudavers[$i]
            $short = $shorts[$i]
            foreach ($pyver in $pyvers) {
              $includes += @{
                pyver = $pyver
                cuda = $cuda
                short = $short
                releasetag = "basic"
              }
            }
          }

          $matrixOut = @{ include = $includes } | ConvertTo-Json -Compress
          Write-Output "matrix=$matrixOut" >> $env:GITHUB_OUTPUT

  build_wheels_cuda:
    name: Build CUDA ${{ matrix.pyver }} ${{ matrix.short }}
    needs: [get_version, define_matrix_cuda]
    runs-on: ubuntu-22.04
    strategy:
      matrix: ${{ fromJSON(needs.define_matrix_cuda.outputs.matrix) }}
    defaults:
      run:
        shell: pwsh
    env:
      CUDAVER: ${{ matrix.cuda }}
      AVXVER: ${{ matrix.releasetag }}

    steps:
      - uses: actions/checkout@v6
        with:
          submodules: "recursive"

      - uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.pyver }}
          cache: 'pip'

      - name: Setup Mamba
        uses: conda-incubator/setup-miniconda@v3.1.0
        with:
          activate-environment: "llamacpp"
          python-version: ${{ matrix.pyver }}
          miniforge-version: latest
          add-pip-as-python-dependency: true
          auto-activate-base: false

      - name: Install Dependencies
        env:
          MAMBA_DOWNLOAD_FAILFAST: "0"
          MAMBA_NO_LOW_SPEED_LIMIT: "1"
        run: |
          mamba install -y 'cuda' -c nvidia/label/cuda-$env:CUDAVER
          python -m pip install build wheel requests cmake
          python -m pip install --upgrade cmake

      - name: Build Wheel
        run: |
          $env:CUDA_PATH = $env:CONDA_PREFIX
          $env:CUDA_HOME = $env:CONDA_PREFIX
          $env:CUDA_TOOLKIT_ROOT_DIR = $env:CONDA_PREFIX
          if ($IsLinux) {
            $env:LD_LIBRARY_PATH = $env:CONDA_PREFIX + '/lib:' + $env:LD_LIBRARY_PATH
          }
          $env:VERBOSE = '1'
          $env:CMAKE_ARGS = '-DGGML_CUDA=on -DCMAKE_CUDA_ARCHITECTURES=all-major -DGGML_CUDA_FORCE_MMQ=ON'
          $env:CMAKE_ARGS = $env:CMAKE_ARGS + ' -DGGML_AVX2=off -DGGML_FMA=off -DGGML_F16C=off'
          python -m build --wheel

      - uses: actions/upload-artifact@v6
        with:
          name: wheel-cuda-${{ matrix.pyver }}-${{ matrix.short }}
          path: dist/*.whl
          retention-days: 4
          if-no-files-found: warn
          overwrite: true

  build_wheels_cpu:
    name: Build CPU ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-22.04, windows-2022]
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: "recursive"

      - uses: actions/setup-python@v6
        with:
          python-version: "3.9"

      - name: Install dependencies (Linux)
        if: runner.os != 'Windows'
        run: |
          python -m pip install --upgrade pip
          python -m pip install uv
          RUST_LOG=trace python -m uv pip install -e .[all] --verbose
          python -m uv pip install cmake
          python -m uv pip install --upgrade cmake
        shell: bash

      - name: Install dependencies (Windows)
        if: runner.os == 'Windows'
        env:
          RUST_LOG: trace
        run: |
          python -m pip install --upgrade pip
          python -m pip install uv
          python -m uv pip install -e .[all] --verbose
          python -m uv pip install cmake
          python -m uv pip install --upgrade cmake
        shell: cmd

      - name: Build wheels
        uses: pypa/cibuildwheel@v3.3.1
        env:
          CIBW_REPAIR_WHEEL_COMMAND: ""
        with:
          package-dir: .
          output-dir: dist

      - uses: actions/upload-artifact@v6
        with:
          name: wheel-cpu-${{ matrix.os }}
          path: dist/*.whl
          retention-days: 4
          if-no-files-found: warn
          overwrite: true

  # Collect and Release Jobs
  # Here we collect the built wheels and create GitHub Releases for each configuration
  # if a release with the same tag exists, we delete it first to avoid conflicts
  # then we create a new release and upload the wheels, overwriting existing assets if any
  # This ensures that the latest wheels are always available under the same release tags

  collect_cpu:
    name: Collect and Release CPU Wheels
    needs: [get_version, build_wheels_cpu]
    runs-on: ubuntu-22.04
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Download Linux CPU wheels
        uses: actions/download-artifact@v6
        with:
          name: wheel-cpu-ubuntu-22.04
          path: dist

      - name: Download Windows CPU wheels
        uses: actions/download-artifact@v6
        with:
          name: wheel-cpu-windows-2022
          path: dist

      - name: Delete existing release if exists
        run: gh release delete "v${{ needs.get_version.outputs.version }}" --yes || true

      - name: Force create tag and release
        run: |
          tag="v${{ needs.get_version.outputs.version }}"
          git tag -f "$tag"
          git push -f origin "$tag"
          gh release create "$tag" --title "v${{ needs.get_version.outputs.version }}" --notes "Automated build"

      - name: Upload wheels
        run: gh release upload "v${{ needs.get_version.outputs.version }}" dist/*.whl --clobber

  collect_cuda:
    name: Collect and Release CUDA ${{ matrix.short }}
    needs: [get_version, build_wheels_cuda]
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        short: [cu121, cu122, cu123, cu124]
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Download wheels for ${{ matrix.short }}
        uses: actions/download-artifact@v6
        with:
          pattern: wheel-cuda-*-${{ matrix.short }}
          path: dist
          merge-multiple: true

      - name: Delete existing release if exists
        run: gh release delete "v${{ needs.get_version.outputs.version }}-${{ matrix.short }}" --yes || true

      - name: Force create tag and release
        run: |
          tag="v${{ needs.get_version.outputs.version }}-${{ matrix.short }}"
          git tag -f "$tag"
          git push -f origin "$tag"
          gh release create "$tag" --title "v${{ needs.get_version.outputs.version }}-${{ matrix.short }}" --notes "Automated build"

      - name: Upload wheels
        run: gh release upload "v${{ needs.get_version.outputs.version }}-${{ matrix.short }}" dist/*.whl --clobber

  # Generate PEP 503-compliant simple index for pip installation from GitHub Pages
  # See: https://peps.python.org/pep-0503/
  generate_pypi_index:
    name: Generate PyPI Index
    needs: [get_version, collect_cpu, collect_cuda]
    runs-on: ubuntu-22.04
    env:
      GITHUB_TOKEN: ${{ github.token }}

    steps:
      - name: Create base directory
        # TODO: make this less hardcoded
        run: mkdir -p dist/whl/{cpu,cu121,cu122,cu123,cu124}

      - name: Generate PEP 503 indices using GitHub API
        env:
          VERSION: ${{ needs.get_version.outputs.version }}
          REPO: ${{ github.repository }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}

        # Due to eventual consistency delays in GitHub Releases API, we implement retries here
        # so that the action waits for the releases to be available and avoid missing assets and wheels.
        # Yes, i could have a external script, but this is easier to manage in one file for now.
        run: |
          python - << 'PYEOF'
          import os
          import requests
          import time

          repo = os.environ['REPO']
          version = os.environ['VERSION']
          token = os.environ['GITHUB_TOKEN']
          repo_owner = os.environ['REPO_OWNER']
          repo_name = os.environ['REPO_NAME']

          package_name = "guanaco-py"

          # Define configurations and their corresponding release tags
          # by example: 'cu121' -> 'v{version}-cu121'
          configs = {
              'cpu': {'tag': f'v{version}', 'label': 'CPU'},
              'cu121': {'tag': f'v{version}-cu121', 'label': 'CUDA 12.1'},
              'cu122': {'tag': f'v{version}-cu122', 'label': 'CUDA 12.2'},
              'cu123': {'tag': f'v{version}-cu123', 'label': 'CUDA 12.3'},
              'cu124': {'tag': f'v{version}-cu124', 'label': 'CUDA 12.4'},
          }

          # GitHub API headers
          headers = {
              'Authorization': f'token {token}',
              'Accept': 'application/vnd.github.v3+json'
          }

          available_configs = []

          # Process each configuration
          # For each, fetch the release info and generate the simple index files
          for config, info in configs.items():
              tag = info['tag']
              url = f'https://api.github.com/repos/{repo}/releases/tags/{tag}'

              # Retry up to 5 times (releases can take seconds to propagate)
              for attempt in range(5):
                  response = requests.get(url, headers=headers)
                  if response.status_code == 200:
                      data = response.json()
                      wheels = sorted([asset['name'] for asset in data.get('assets', []) if asset['name'].endswith('.whl')])
                      break
                  else:
                      print(f"Attempt {attempt+1}: Release {tag} not ready yet (status {response.status_code})")
                      time.sleep(10)
              else:
                  print(f"âœ— Failed to fetch release {tag}")
                  wheels = []

              if not wheels:
                  print(f"âœ— No wheels found for {info['label']}")
                  continue

              # Simple index: /whl/{config}/index.html
              config_dir = f'dist/whl/{config}'
              os.makedirs(config_dir, exist_ok=True)
              with open(f'{config_dir}/index.html', 'w', encoding='utf-8') as f:
                  f.write('<!DOCTYPE html>\n<html>\n  <head><title>simple index</title></head>\n  <body>\n')
                  f.write(f'    <a href="{package_name}/">{package_name}</a><br/>\n')
                  f.write('  </body>\n</html>\n')

              # Project page: /whl/{config}/{package_name}/index.html
              package_dir = f'{config_dir}/{package_name}'
              os.makedirs(package_dir, exist_ok=True)
              with open(f'{package_dir}/index.html', 'w', encoding='utf-8') as f:
                  f.write('<!DOCTYPE html>\n<html>\n  <head>\n')
                  f.write(f'    <title>Links for {package_name}</title>\n')
                  f.write('  </head>\n  <body>\n')
                  f.write(f'    <h1>Links for {package_name}</h1>\n')
                  for wheel in wheels:
                      download_url = f"https://github.com/{repo}/releases/download/{tag}/{wheel}"
                      f.write(f'    <a href="{download_url}">{wheel}</a><br/>\n')
                  f.write('  </body>\n</html>\n')

              print(f"âœ“ Generated indices for {info['label']} ({len(wheels)} wheels)")
              available_configs.append((config, info['label']))

          # Root page
          root_lines = [
              '<!DOCTYPE html>',
              '<html>',
              '  <head><title>guanaco-py - PyPI Index</title></head>',
              '  <body>',
              '    <h1>ðŸ¦™ Guanaco Wheels</h1>',
              '    <p>Pre-compiled wheels with CPU and CUDA support (hosted on GitHub Releases).</p>',
              '    <p>Note: pip may warn about no hash verification - safe as downloads are direct from GitHub.</p>',
          ]

          for config, label in available_configs:
              index_url = f"https://{repo_owner}.github.io/{repo_name}/whl/{config}/"
              root_lines.extend([
                  f'    <h2>{label}</h2>',
                  '    <p><strong>Install:</strong></p>',
                  f'    <p><code>pip install guanaco-py --extra-index-url {index_url}</code></p>',
                  '    <p><strong>Force wheels only:</strong></p>',
                  f'    <p><code>pip install guanaco-py --only-binary=:all: --extra-index-url {index_url}</code></p>',
                  f'    <p><a href="whl/{config}/">Simple index â†’</a> | <a href="whl/{config}/{package_name}/">Full wheel list â†’</a></p>',
              ])

          root_lines.extend([
              '    <hr/>',
              '    <p>Generated by GitHub Actions â€¢ Wheels in Releases for history</p>',
              '  </body>',
              '</html>'
          ])

          with open('dist/index.html', 'w', encoding='utf-8') as f:
              f.write('\n'.join(root_lines))

          print("âœ“ Generated root index")
          PYEOF

      # Create README for the GitHub Pages site
      # TODO: make it more beautiful later
      - name: Create README
        run: |
          cat > dist/README.md << 'EOF'
          # ðŸ¦™ Guanaco Wheels

          Pre-compiled wheels with CPU and CUDA support.

          See main page for installation commands.

          **Repository**: https://github.com/${{ github.repository }}
          EOF

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: dist

  deploy_pages:
    name: Deploy to GitHub Pages
    needs: generate_pypi_index
    runs-on: ubuntu-22.04
    environment:
      name: github-pages
      url: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/
    steps:
      - name: Deploy
        uses: actions/deploy-pages@v4
